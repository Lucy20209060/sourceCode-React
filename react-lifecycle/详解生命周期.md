1.使用 createClass 创建自定义组件
    createClass是创建自定义组件的入口方法 负责管理生命周期中的getDefaultProps 该方法在整个生命周期只在执行一次 这样所有的实例初始化的props将会被共享
    通过createClass创建自定义组件 利用原型继承ReactClassComponent父类 按顺序合并mixin 设置初始值defaultProps 返回构造函数
    当使用ES6 classes编写React组件时 class MyComponent extends React.Component 其实就是调用内部的createClass创建组件

2.阶段一：mounting
    mountComponent 负责管理生命周期的 getInitialState componentWillMount render ComponentDidMount 
    由于getDefaultProps是通过构造函数进行管理的 所以也会整个生命周期最开始执行的 mountComponent无法调用到getDefaultprops 这就解释了为什么getDefaultProps只执行一次

    由于通过ReactCompositeComponent返回的是一个虚拟的节点 所以需要利用intantiatereactComponent去得到实例 在使用mountComponent拿到结果作为当前自定义元素的结果

    通过mountComponent挂载组件 初始化序列号 标记等参数 判断是否为无状态组件 并进行对应的组件初始化工作 比如初始化props context等参数 利用getInitialState获取初始化state 初始化更新队列和更新状态

    若存在componentWillMount 则执行 如果此时在componentWillMount中调用setState方法是不会触发re-render的 而是进行state合并 且 inst.state = this._processPendingState(inst.props,inst.comtext)是在componentWillMount之后执行的 因此componentWillmount中的this.state并不是最新的 在render中才可以获取最新的this.state

    因此 React是利用更新队列 this._pendingStateQueue以及更新状态 this._pendingReplaceState 和 this._pendingForceUpdate 来实现setState的异步更新机制

    当渲染完成 若存在componentDidMount 则调用 这就解释了 componentWillMount render componentDidMount这三者之间的执行顺序

    其实mountConponent本质上是通过递归渲染内容的 由于递归的特征 父组件的componentWillMount在其子组件的componentWillMount之前调用 而父组件的componentDidMount在其子组件的componentDidMount之后调用

3.阶段二：receive_props




4.阶段三：unmounting
